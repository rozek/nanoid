{"version":3,"file":"nanoid.umd.js","sources":["../url-alphabet/index.js","../index.browser.js"],"sourcesContent":["// This alphabet uses `A-Za-z0-9_-` symbols.\n// The order of characters is optimized for better gzip and brotli compression.\n// Same as in non-secure/index.js\nexport const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\n\n// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\n\nexport { urlAlphabet } from './url-alphabet/index.js'\n\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step | 0\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\n\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\n\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    // Using the bitwise AND operator to \"cap\" the value of\n    // the random byte from 255 to 63, in that way we can make sure\n    // that the value will be a valid index for the \"chars\" string.\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n"],"names":["urlAlphabet","random","bytes","crypto","getRandomValues","Uint8Array","customRandom","alphabet","defaultSize","getRandom","mask","Math","log2","length","step","size","id","j","scopedUrlAlphabet"],"mappings":"gOAGa,IAAAA,EACX,mECKSC,EAAS,SAAAC,GAAS,OAAAC,OAAOC,gBAAgB,IAAIC,WAAWH,GAAO,EAE/DI,EAAe,SAACC,EAAUC,EAAaC,GAMhD,IAAIC,GAAQ,GAAKC,KAAKC,KAAKL,EAASM,OAAS,IAAM,EAgB/CC,KAAW,IAAMJ,EAAOF,EAAeD,EAASM,QAEpD,OAAQE,SAAAA,QAAI,IAAJA,IAAAA,EAAOP,GAEb,IADA,IAAIQ,EAAK,KAKP,IAHA,IAAId,EAAQO,EAAUK,GAElBG,EAAW,EAAPH,EACDG,KAGL,IADAD,GAAMT,EAASL,EAAMe,GAAKP,IAAS,IAC5BG,QAAUE,EAAM,OAAOC,CAGpC,CACF,mBAE4B,SAACT,EAAUQ,GACrC,YADqCA,IAAAA,IAAAA,EAAO,IAC5CT,EAAaC,EAAiB,EAAPQ,EAAUd,EAAO,4BAEtB,SAACc,QAAAA,IAAAA,IAAAA,EAAO,IAG1B,IAFA,IAAIC,EAAK,GACLd,EAAQC,OAAOC,gBAAgB,IAAIC,WAAYU,GAAQ,IACpDA,KAILC,GAAME,EAAgC,GAAdhB,EAAMa,IAEhC,OAAOC,CACT"}